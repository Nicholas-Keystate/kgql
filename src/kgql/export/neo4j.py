# -*- encoding: utf-8 -*-
"""
KGQL Neo4j Cypher Exporter.

Generates Neo4j Cypher CREATE statements from PropertyGraph.

Output can be:
- Pasted into Neo4j Browser
- Executed via Neo4j Python driver
- Saved as .cypher file for batch import

Example Output:
    // Generated by KGQL export — credential graph
    CREATE (n0:Credential {said: 'ESAID1...', issuer: 'EAID1...'})
    CREATE (n1:Credential {said: 'ESAID2...', issuer: 'EAID2...'})
    CREATE (n0)-[:ACDC {operator: 'I2I'}]->(n1)

Usage:
    from kgql.export import PropertyGraph
    from kgql.export.neo4j import export_neo4j

    cypher = export_neo4j(graph)
    print(cypher)  # Ready for Neo4j
"""

from typing import Optional

from kgql.export.graph import PropertyGraph, GraphNode, GraphEdge, NodeType


def export_neo4j(
    graph: PropertyGraph,
    variable_prefix: str = "n",
    include_header: bool = True,
) -> str:
    """
    Generate Neo4j Cypher CREATE statements from PropertyGraph.

    Creates nodes with labels based on node type and properties,
    then creates relationships with edge type as the relationship type.

    Args:
        graph: PropertyGraph to export
        variable_prefix: Prefix for node variables (default "n")
        include_header: Include comment header (default True)

    Returns:
        String of Cypher CREATE statements
    """
    lines = []

    if include_header:
        lines.append("// Generated by KGQL export — credential graph")
        node_count = graph.node_count()
        edge_count = graph.edge_count()
        lines.append(f"// Nodes: {node_count}, Edges: {edge_count}")
        lines.append("")

    # Build SAID → variable mapping
    said_to_var: dict[str, str] = {}
    for idx, said in enumerate(graph.nodes.keys()):
        said_to_var[said] = f"{variable_prefix}{idx}"

    # Generate CREATE statements for nodes
    for said, node in graph.nodes.items():
        var = said_to_var[said]
        cypher = _node_to_cypher(node, var)
        lines.append(cypher)

    # Add blank line between nodes and edges
    if graph.edges:
        lines.append("")

    # Generate CREATE statements for edges
    for edge in graph.edges:
        source_var = said_to_var.get(edge.source_said)
        target_var = said_to_var.get(edge.target_said)

        if source_var and target_var:
            cypher = _edge_to_cypher(edge, source_var, target_var)
            lines.append(cypher)
        else:
            # Edge references node not in graph — skip with comment
            lines.append(
                f"// SKIPPED: Edge {edge.source_said[:12]}... -> {edge.target_said[:12]}... "
                f"(missing node)"
            )

    return "\n".join(lines)


def export_neo4j_merge(
    graph: PropertyGraph,
    variable_prefix: str = "n",
    include_header: bool = True,
) -> str:
    """
    Generate Neo4j Cypher MERGE statements from PropertyGraph.

    Uses MERGE instead of CREATE to avoid duplicates. Useful for
    incremental graph updates.

    Args:
        graph: PropertyGraph to export
        variable_prefix: Prefix for node variables (default "n")
        include_header: Include comment header (default True)

    Returns:
        String of Cypher MERGE statements
    """
    lines = []

    if include_header:
        lines.append("// Generated by KGQL export — credential graph (MERGE mode)")
        node_count = graph.node_count()
        edge_count = graph.edge_count()
        lines.append(f"// Nodes: {node_count}, Edges: {edge_count}")
        lines.append("")

    # Build SAID → variable mapping
    said_to_var: dict[str, str] = {}
    for idx, said in enumerate(graph.nodes.keys()):
        said_to_var[said] = f"{variable_prefix}{idx}"

    # Generate MERGE statements for nodes
    for said, node in graph.nodes.items():
        var = said_to_var[said]
        cypher = _node_to_cypher(node, var, use_merge=True)
        lines.append(cypher)

    if graph.edges:
        lines.append("")

    # Generate MERGE statements for edges
    for edge in graph.edges:
        source_var = said_to_var.get(edge.source_said)
        target_var = said_to_var.get(edge.target_said)

        if source_var and target_var:
            cypher = _edge_to_cypher(edge, source_var, target_var, use_merge=True)
            lines.append(cypher)

    return "\n".join(lines)


def _node_to_cypher(
    node: GraphNode,
    var: str,
    use_merge: bool = False,
) -> str:
    """
    Convert GraphNode to Cypher CREATE/MERGE statement.

    Example:
        CREATE (n0:Credential {said: 'ESAID...', issuer: 'EAID...'})
    """
    # Map node type to Neo4j label
    label = _node_type_to_label(node.node_type)

    # Build properties dict
    props = {"said": node.said}
    if node.issuer:
        props["issuer"] = node.issuer
    if node.schema:
        props["schema"] = node.schema
    if node.label:
        props["label"] = node.label
    if node.key_state_seq is not None:
        props["key_state_seq"] = node.key_state_seq
    if node.delegation_depth is not None:
        props["delegation_depth"] = node.delegation_depth
    if node.issued_at:
        props["issued_at"] = node.issued_at
    if node.revoked_at:
        props["revoked_at"] = node.revoked_at
    if node.registry:
        props["registry"] = node.registry

    # Include attributes as nested properties
    if node.attributes:
        for key, value in node.attributes:
            props[f"attr_{key}"] = value

    props_cypher = _props_to_cypher(props)
    verb = "MERGE" if use_merge else "CREATE"

    return f"{verb} ({var}:{label} {props_cypher})"


def _edge_to_cypher(
    edge: GraphEdge,
    source_var: str,
    target_var: str,
    use_merge: bool = False,
) -> str:
    """
    Convert GraphEdge to Cypher CREATE/MERGE relationship statement.

    Example:
        CREATE (n0)-[:ACDC {operator: 'I2I'}]->(n1)
    """
    # Edge type becomes relationship type (uppercase)
    rel_type = edge.edge_type.upper()

    # Build properties
    props = {"operator": edge.operator}
    if edge.weight is not None:
        props["weight"] = edge.weight
    if edge.metadata:
        for key, value in edge.metadata:
            props[key] = value

    props_cypher = _props_to_cypher(props)
    verb = "MERGE" if use_merge else "CREATE"

    return f"{verb} ({source_var})-[:{rel_type} {props_cypher}]->({target_var})"


def _props_to_cypher(props: dict) -> str:
    """
    Convert properties dict to Cypher property map syntax.

    Example:
        {said: 'ESAID...', issuer: 'EAID...'}
    """
    parts = []
    for key, value in props.items():
        if isinstance(value, str):
            escaped = _cypher_escape(value)
            parts.append(f"{key}: '{escaped}'")
        elif isinstance(value, bool):
            parts.append(f"{key}: {str(value).lower()}")
        elif isinstance(value, (int, float)):
            parts.append(f"{key}: {value}")
        elif value is None:
            continue  # Skip null values
        else:
            # Convert to string for other types
            escaped = _cypher_escape(str(value))
            parts.append(f"{key}: '{escaped}'")

    return "{" + ", ".join(parts) + "}"


def _cypher_escape(value: str) -> str:
    """
    Escape single quotes and backslashes for Cypher string literals.

    Cypher strings use single quotes, so we need to escape:
    - Single quotes: ' → \\'
    - Backslashes: \\ → \\\\
    """
    return value.replace("\\", "\\\\").replace("'", "\\'")


def _node_type_to_label(node_type: NodeType) -> str:
    """
    Map NodeType enum to Neo4j label.

    Uses PascalCase for Neo4j conventions.
    """
    label_map = {
        NodeType.CREDENTIAL: "Credential",
        NodeType.IDENTIFIER: "Identifier",
        NodeType.SCHEMA: "Schema",
        NodeType.FRAMEWORK: "Framework",
    }
    return label_map.get(node_type, "Node")
